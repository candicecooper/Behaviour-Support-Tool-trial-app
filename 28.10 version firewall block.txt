import streamlit as st
import pandas as pd
# --- FIXED: Explicitly importing time along with datetime and timedelta to resolve NameError ---
from datetime import datetime, timedelta, time 
import random
import uuid 

# --- Configuration and Aesthetics (SET PAGE CONFIG MUST BE AT THE TOP) ---
st.set_page_config(
    page_title="Supabase Streamlit Data Viewer",
    layout="wide",
    initial_sidebar_state="collapsed",
)
# --------------------------------------------------------------------

# --- Data Generation Functions (Needed for app logic) ---

def get_random_time():
    """Generates a random time object between 8:00 and 16:00."""
    start = datetime(2025, 1, 1, 8, 0, 0)
    end = datetime(2025, 1, 1, 16, 0, 0)
    random_seconds = random.randint(0, int((end - start).total_seconds()))
    # .time() is now available because we imported it explicitly
    return (start + timedelta(seconds=random_seconds)).time() 

def get_session_from_time(t):
    """Maps a time object to a session name."""
    if time(8, 30) <= t <= time(11, 0):
        return "Morning Session"
    elif time(11, 0) < t <= time(13, 0):
        return "Midday Session (Break/Lunch)"
    elif time(13, 0) < t <= time(15, 30):
        return "Afternoon Session"
    else:
        return "Before/After Hours"

def generate_mock_incidents():
    """Generates a list of mock incident records."""
    # Mock students and behaviors
    students = [
        {'name': 'Alex Johnson', 'id': str(uuid.uuid4())},
        {'name': 'Maria Sanchez', 'id': str(uuid.uuid4())},
        {'name': 'Ethan Lee', 'id': str(uuid.uuid4())},
    ]
    behaviors = ["Shouting", "Refusal to Follow Instructions", "Physical Aggression", "Property Destruction", "Elopement"]
    locations = ["Classroom A", "Library", "Playground", "Hallway"]
    staff = ["Ms. Rodriguez", "Mr. Thompson", "Nurse Miller"]
    
    incidents = []
    for i in range(50): # Generate 50 mock incidents
        student = random.choice(students)
        incident_time = get_random_time()
        
        incidents.append({
            'id': str(uuid.uuid4()),
            'student_id': student['id'],
            'student_name': student['name'],
            'date': (datetime.now() - pd.Timedelta(days=random.randint(1, 45))).strftime('%Y-%m-%d'),
            'time': incident_time.strftime('%H:%M:%S'),
            'session': get_session_from_time(incident_time),
            'behavior': random.choice(behaviors),
            'intensity': random.choice(['Low', 'Medium', 'High']),
            'location': random.choice(locations),
            'staff': random.choice(staff),
            'description': f"Mock incident: {random.choice(behaviors)} observed at {random.choice(locations)}."
        })
    return incidents

# --- Supabase Connection Logic ---

@st.cache_data(ttl=600)
def run_query(_conn):
    """
    Executes the SQL query to fetch data from the public.profiles table.
    """
    query = 'SELECT * FROM "public"."profiles";' 
    df = _conn.query(query)
    return df

    
# The main application logic
try:
    # This call looks for the configuration in [connections.postgresql] 
    # inside .streamlit/secrets.toml
    conn = st.connection("postgresql", type="sql")
    st.success("Connection to Supabase established successfully! (Attempting Query...)") 
    
    # Run the query and display data
    data_df = run_query(conn) 

    st.header("Data from Supabase ('public.profiles' table)")
    st.dataframe(data_df)

    # Initialize mock incidents if the database call succeeded (optional mock data display)
    if 'incidents' not in st.session_state:
        st.session_state.incidents = generate_mock_incidents()
    
    # Optional: Display the mock incidents for verification
    # st.subheader("Mock Incidents Data (Using generate_mock_incidents)")
    # st.dataframe(pd.DataFrame(st.session_state.incidents))


# Error handling for connection or query failure
except Exception as e:
    # Display the final error to the user
    st.error(f"Failed to load data. The remaining issues are either a **DNS resolution failure** (Name or service not known) or a malformed **secrets.toml** Canvas.")
    st.exception(e)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)



# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)


# (The large block of student/incident logging code found in the original snippet 
# is omitted here for brevity and focus, but should remain in your local file.)

# --- Configuration and Aesthetics (High-Contrast Dark Look) ---

st.set_page_config(
    page_title="Behaviour Support & Data Analysis Tool",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Define Plotly Theme for Dark Mode Consistency
PLOTLY_THEME = 'plotly_dark'

# --- FBA and Data Constants ---

MOCK_STAFF = [
    {'id': 's1', 'name': 'Emily Jones (JP)', 'role': 'JP', 'active': True, 'special': False},
    {'id': 's2', 'name': 'Daniel Lee (PY)', 'role': 'PY', 'active': True, 'special': False},
    {'id': 's3', 'name': 'Sarah Chen (SY)', 'role': 'SY', 'active': True, 'special': False},
    {'id': 's4', 'name': 'Admin User (ADM)', 'role': 'ADM', 'active': True, 'special': False},
    # Special roles that require manual name input
    {'id': 's_trt', 'name': 'TRT', 'role': 'TRT', 'active': True, 'special': True},
    {'id': 's_sso', 'name': 'External SSO', 'role': 'SSO', 'active': True, 'special': True},
]

MOCK_STUDENTS = [
    {'id': 'stu_jp_high', 'name': 'Marcus A.', 'area': 'JP', 'grade': 'R', 'teacher': 'Smith', 'edid': 'JP001A', 'dob': '2019-03-15'},
    {'id': 'stu_jp_low', 'name': 'Chloe T.', 'area': 'JP', 'grade': 'Y2', 'teacher': 'Davids', 'edid': 'JP002T', 'dob': '2017-11-20'},
    {'id': 'stu_py_high', 'name': 'Noah K.', 'area': 'PY', 'grade': 'Y5', 'teacher': 'Williams', 'edid': 'PY003K', 'dob': '2014-07-01'},
    {'id': 'stu_py_low', 'name': 'Leah S.', 'area': 'PY', 'grade': 'Y6', 'teacher': 'Brown', 'edid': 'PY004S', 'dob': '2013-09-10'},
    {'id': 'stu_sy_high', 'name': 'Ethan B.', 'area': 'SY', 'grade': 'Y9', 'teacher': 'Green', 'edid': 'SY005B', 'dob': '2010-01-25'},
    {'id': 'stu_sy_low', 'name': 'Mia P.', 'area': 'SY', 'grade': 'Y10', 'teacher': 'Clark', 'edid': 'SY006P', 'dob': '2009-04-05'},
]

BEHAVIORS_FBA = ['Verbal Refusal', 'Elopement', 'Property Destruction', 'Aggression (Peer)', 'Self-Injurious Behaviour', 'Out of Seat', 'Non-Compliance', 'Physical Aggression (Staff)']
WINDOW_OF_TOLERANCE = ['Hypo-aroused', 'Hyper-aroused', 'Coping'] 
SETTINGS = ['Classroom', 'Gate', 'Yard', 'Playground', 'Toilets', 'Admin', 'Spill out', 'Kitchen', 'Library', 'Excursion', 'Swimming', 'Bus/Van', 'Specialist Lesson']
SUPPORT_TYPES = ['Unstructured', 'Small Group', 'Independent', 'Large Group', 'Peer', '1:1']
ANTECEDENTS_NEW = ['Peer Interaction', 'Tired', 'Hungry', 'Transition', 'Routine Change', 'Environmental Disturbance', 'Limit Setting', 'Group Work', 'Adult Demand', 'No Medication', 'Task Demand', 'Other']
FUNCTIONAL_HYPOTHESIS = ['Seek/Get Something', 'Avoid/Escape Something', 'Self Stimulation']
FUNCTION_PRIMARY = ['Sensory', 'Social', 'Tangible/Activity']
FUNCTION_SECONDARY = ['Peer', 'Adult', '-'] 
RISK_LEVELS = [1, 2, 3, 4, 5] # 1=Low, 5=Extreme

CONSEQUENCES = ['Redirection/Prompt', 'Time-Out (Brief)', 'Ignored (Planned)', 'Preferred Activity Access']
INTERVENTION_EFFECTIVENESS = ['Highly Effective', 'Moderately Effective', 'Ineffective', 'Worsened Behaviour']
DAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
HOW_TO_RESPOND_DEFAULT = "No detailed plan required or specified."


# --- Utility Functions ---

def get_session_from_time(t):
    """Determines the session based on time of day."""
    if time(8, 30) <= t <= time(11, 0):
        return 'Morning (8:30-11:00)'
    elif time(11, 1) <= t <= time(13, 0):
        return 'Middle (11:01-1:00)'
    elif time(13, 1) <= t <= time(15, 0):
        return 'Afternoon (1:01-3:00)'
    else:
        return 'Outside Hours'

def get_random_time():
    """Generates a random time between 8:30 and 15:00."""
    start = datetime(2000, 1, 1, 8, 30, 0)
    end = datetime(2000, 1, 1, 15, 0, 0)
    random_seconds = random.randint(0, int((end - start).total_seconds()))
    return (start + timedelta(seconds=random_seconds)).time()

def get_time_slot(t):
    """Converts time to the nearest half-hour slot for heatmap."""
    minutes = t.minute
    hour = t.hour
    if minutes < 30:
        return f"{hour:02d}:00"
    else:
        return f"{hour:02d}:30"

def generate_mock_abch_outcomes():
    """Generates random outcomes for critical incidents (for mock data)."""
    outcomes = {
        'outcome_send_home': random.choice([True, False]),
        'outcome_leave_area': random.choice([True, False]),
        'outcome_assault': random.choice([True, False]),
        'outcome_property_damage': random.choice([True, False]),
        'outcome_staff_injury': random.choice([True, False]),
        'outcome_sapol_callout': random.choice([True, False]),
        'outcome_ambulance': random.choice([True, False]),
    }
    if not any(outcomes.values()):
        outcomes[random.choice(list(outcomes.keys()))] = True
    
    return outcomes

def generate_mock_incidents():
    """Generates a list of mock incident dictionaries with new FBA fields and outcomes."""
    incidents = []
    
    # 1. High Incident Student (Marcus A. - stu_jp_high) - 15 incidents
    for i in range(1, 16):
        incident_date = (datetime.now() - pd.Timedelta(days=random.randint(1, 45))).strftime('%Y-%m-%d')
        incident_time = get_random_time()
        
        is_high_risk = random.choice([True, True, False])
        
        behaviour = random.choice(['Verbal Refusal', 'Elopement', 'Physical Aggression (Staff)']) if i % 3 == 0 else random.choice(BEHAVIORS_FBA)
        risk = random.choice([4, 5]) if is_high_risk else random.choice([1, 2, 3])
        
        incident_data = {
            'id': str(uuid.uuid4()),
            'student_id': 'stu_jp_high',
            'date': incident_date,
            'time': incident_time.strftime('%H:%M'),
            'day': datetime.strptime(incident_date, '%Y-%m-%d').strftime('%A'),
            'session': get_session_from_time(incident_time),
            'behaviour': behaviour,
            'window_of_tolerance': random.choice(['Hyper-aroused']) if is_high_risk else random.choice(WINDOW_OF_TOLERANCE),
            'setting': random.choice(['Classroom', 'Yard']),
            'support_type': random.choice(['1:1', 'Small Group']) if is_high_risk else random.choice(SUPPORT_TYPES),
            'antecedent': random.choice(['Task Demand', 'Limit Setting', 'Adult Demand']),
            'func_hypothesis': random.choice(['Avoid/Escape Something', 'Seek/Get Something']),
            'func_primary': random.choice(FUNCTION_PRIMARY),
            'func_secondary': random.choice(FUNCTION_SECONDARY),
            'risk_level': risk,
            'consequence': random.choice(CONSEQUENCES), 
            'effectiveness': random.choice(['Ineffective', 'Worsened Behaviour']) if is_high_risk else random.choice(['Highly Effective', 'Moderately Effective']),
            'logged_by': 's1',
            'other_staff': ['s_trt:Jane Doe'] if i % 5 == 0 else [],
            'is_abch_completed': is_high_risk,
            'context': f"HIGH-DETAIL LOG: {behaviour} during {incident_time.strftime('%H:%M')}. Requires immediate follow-up." if is_high_risk else "Basic log captured. No detailed context entered.",
            'notes': f"Staff noted lack of sleep prior to incident {i}.",
            'how_to_respond': "Use a 5-step break card system." if is_high_risk else HOW_TO_RESPOND_DEFAULT
        }
        
        if is_high_risk:
            incident_data.update(generate_mock_abch_outcomes())
        else:
            incident_data.update({
                'outcome_send_home': False, 'outcome_leave_area': False, 
                'outcome_assault': False, 'outcome_property_damage': False, 
                'outcome_staff_injury': False, 'outcome_sapol_callout': False, 
                'outcome_ambulance': False,
            })
            
        incidents.append(incident_data)

    # 2. Other students (3 incidents each)
    for student in MOCK_STUDENTS:
        if student['id'] == 'stu_jp_high':
            continue

        for i in range(1, 4):
            incident_date = (datetime.now() - pd.Timedelta(days=random.randint(1, 60))).strftime('%Y-%m-%d')
            incident_time = get_random_time()
            
            incident_data = {
                'id': str(uuid.uuid4()),
                'student_id': student['id'],
                'date': incident_date,
                'time': incident_time.strftime('%H:%M'),
                'day': datetime.strptime(incident_date, '%Y-%m-%d').strftime('%A'),
                'session': get_session_from_time(incident_time),
                'behaviour': random.choice(BEHAVIORS_FBA),
                'window_of_tolerance': random.choice(WINDOW_OF_TOLERANCE),
                'setting': random.choice(SETTINGS),
                'support_type': random.choice(SUPPORT_TYPES),
                'antecedent': random.choice(ANTECEDENTS_NEW),
                'func_hypothesis': random.choice(FUNCTIONAL_HYPOTHESIS),
                'func_primary': random.choice(FUNCTION_PRIMARY),
                'func_secondary': random.choice(FUNCTION_SECONDARY),
                'risk_level': random.choice(RISK_LEVELS),
                'consequence': random.choice(CONSEQUENCES), 
                'effectiveness': random.choice(INTERVENTION_EFFECTIVENESS),
                'logged_by': random.choice(['s1', 's2', 's3']),
                'other_staff': [],
                'is_abch_completed': False,
                'context': "Basic log captured. No detailed context entered.",
                'notes': None,
                'how_to_respond': HOW_TO_RESPOND_DEFAULT
            }
            incident_data.update({
                'outcome_send_home': False, 'outcome_leave_area': False, 
                'outcome_assault': False, 'outcome_property_damage': False, 
                'outcome_staff_injury': False, 'outcome_sapol_callout': False, 
                'outcome_ambulance': False,
            })
            incidents.append(incident_data)
            
    return incidents


# --- Session State Initialization ---

if 'current_page' not in st.session_state:
    st.session_state.current_page = 'landing'
if 'current_role' not in st.session_state:
    st.session_state.current_role = None 
if 'students' not in st.session_state:
    st.session_state.students = MOCK_STUDENTS
if 'incidents' not in st.session_state:
    st.session_state.incidents = generate_mock_incidents()
if 'staff' not in st.session_state:
    st.session_state.staff = MOCK_STAFF
if 'selected_student_id' not in st.session_state:
    st.session_state.selected_student_id = None
if 'mode' not in st.session_state:
    st.session_state.mode = 'home'
if 'temp_log_area' not in st.session_state:
    st.session_state.temp_log_area = None
if 'temp_incident_data' not in st.session_state:
    st.session_state.temp_incident_data = None
if 'abch_chronology' not in st.session_state:
    st.session_state.abch_chronology = []


# --- Utility Functions ---

def navigate_to(page_name, role=None, mode='home', student_id=None):
    """Sets the session state to change the current page, role, and mode."""
    st.session_state.current_page = page_name
    if role:
        st.session_state.current_role = role
    st.session_state.mode = mode
    st.session_state.selected_student_id = student_id
    st.session_state.temp_log_area = None
    st.rerun()

def get_students_by_area(area):
    """Filters students by the current staff area (JP, PY, SY)."""
    return [s for s in st.session_state.students if s['area'] == area]

def get_student_by_id(student_id):
    """Retrieves a student dictionary by ID."""
    return next((s for s in st.session_state.students if s['id'] == student_id), None)

def get_incidents_by_student(student_id):
    """Retrieves incidents for a single student."""
    return [i for i in st.session_state.incidents if i['student_id'] == student_id]

def get_active_staff():
    """Returns only active staff members (excluding 'on hold')."""
    return [s for s in st.session_state.staff if s['active'] == True]

def guess_function(consequence_text):
    """Simple keyword analysis to auto-guess function (Avoid or Seek)."""
    if not consequence_text:
        return 'Seek/Avoid Something'

    consequence_text = consequence_text.lower()
    if any(keyword in consequence_text for keyword in ['removed', 'left', 'escape', 'task stopped', 'terminated', 'break', 'redirection']):
        return 'Avoid/Escape Something'
    if any(keyword in consequence_text for keyword in ['attention', 'gained access', 'reward', 'preferred', 'given choice', 'received item', 'time-out']):
        return 'Seek/Get Something'
    return 'Seek/Avoid Something'

def add_abch_entry():
    """Adds a new blank entry to the chronological log."""
    new_entry = {
        'id': str(uuid.uuid4()),
        'location': '',
        'context': '',
        'time': datetime.now().strftime('%H:%M'),
        'behaviour': '',
        'consequence': '',
        'function_auto': 'Unknown'
    }
    st.session_state.abch_chronology.append(new_entry)

# --- FBA Plan Content Generation and Download (FIX APPLIED HERE) ---

def generate_fba_report_content(student, latest_plan_incident, df):
    """
    Generates the structured text content for the full FBA report.
    FIX: Switched outer f-string delimiter from triple double-quotes to triple single-quotes (f'''...''')
    to prevent premature termination from nested triple double-quotes in user data.
    """
    
    # 1. Gather Key Data Insights for the Summary
    total_incidents = len(df)
    critical_incidents = df['is_abch_completed'].sum()
    most_freq_behaviour = df['behaviour'].mode().iloc[0] if not df.empty else 'N/A'
    peak_risk = df['risk_level'].max() if not df.empty else 'N/A'
    
    # 2. CPI Stage Determination
    if most_freq_behaviour in ['Physical Aggression (Staff)', 'Self-Injurious Behaviour', 'Property Destruction'] or peak_risk >= 4:
        cpi_stage = "High-Risk: Acting Out (Danger)"
        cpi_response = "Nonviolent Physical Crisis Intervention (where appropriate) followed by Therapeutic Rapport to restore the relationship and process the event."
    elif most_freq_behaviour in ['Aggression (Peer)', 'Elopement', 'Verbal Refusal'] or peak_risk == 3:
        cpi_stage = "Peak Risk: Defensive"
        cpi_response = "Use Paraverbal Communication (tone, volume, cadence) to reduce tension. Offer choices and time to decide, avoiding power struggles."
    else:
        cpi_stage = "Low-Risk: Questioning / Refusal"
        cpi_response = "Use Supportive language and provide a clear, concise direction. Re-direct the focus from the demand to the goal."
    
    # Prepare content for insertion
    how_to_respond_content = latest_plan_incident['how_to_respond'] if latest_plan_incident else 'No detailed action plan available from a completed ABCH log.'
        
    
    # Using triple SINGLE quotes (''') for the outer f-string.
    content = f'''
# FUNCTIONAL BEHAVIOURAL ASSESSMENT (FBA) PLAN
## Student: {student['name']} (EDID: {student.get('edid', 'N/A')})
**Date of Birth:** {student.get('dob', 'N/A')}
**Grade/Class:** {student['grade']} ({student['teacher']})
**Date Report Generated:** {datetime.now().strftime('%Y-%m-%d')}
**Report Status:** Active Plan

---

## 1. Summary of Key Behavioural Data

| Metric | Value |
| :--- | :--- |
| **Total Incidents (Last 60 Days)** | {total_incidents} |
| **Critical Incidents (ABCH Logs)** | {critical_incidents} |
| **Most Frequent Behaviour** | {most_freq_behaviour} |
| **Highest Recorded Risk Level** | {peak_risk} |
| **Primary Functional Hypothesis** | {latest_plan_incident['func_hypothesis'] if latest_plan_incident else 'N/A'} |
| **Primary Antecedent (Trigger)** | {latest_plan_incident['antecedent'] if latest_plan_incident else 'N/A'} |
| **Window of Tolerance State** | {latest_plan_incident['window_of_tolerance'] if latest_plan_incident else 'N/A'} |

---

## 2. Comprehensive Action Plan (How to Respond)

This section outlines the immediate and strategic responses derived from the last critical incident analysis.

### Primary De-escalation Strategy (The 'H' in ABCH)
**Last Updated:** {latest_plan_incident['date'] if latest_plan_incident else 'N/A'}

{how_to_respond_content}


### Crisis Prevention Institute (CPI) Protocol
The student is currently demonstrating behaviours aligning with the **{cpi_stage}** stage of the CPI Verbal Escalation Continuum.
* **Recommended Staff Response:** {cpi_response}
* **Goal:** Maintain safety and use *Supportive* and *Directive* nonverbal strategies to prevent physical acting out.

---

## 3. Proactive, Trauma-Informed Strategies (The 'Education Lens')

These strategies are designed to build skills and regulate the student's nervous system, reducing the need for the problem behaviour.

### A. Regulation (Body-Based/Physiological)
* **Strategy:** Daily **Sensory Check-in** upon arrival and after lunch.
* **Action:** Provide **heavy work** or a **Brain Break** 5 minutes *before* the identified peak time. Use a visual timer.
* **Targeted State:** Address the **{latest_plan_incident['window_of_tolerance'] if latest_plan_incident else 'Hyper-aroused'}** state before it escalates.

### B. Relate (Relational/Connection)
* **Strategy:** Implement a **Predictable Check-in/Check-out** system.
* **Action:** A designated **Safe Adult** provides a 30-second non-contingent (no demands) positive connection at every transition.
* **Targeted Function:** Build a secure relational base to reduce the need to **{latest_plan_incident['func_hypothesis'].split('/')[0].strip().lower() if latest_plan_incident else 'seek/avoid'}** adult attention through misbehaviour.

### C. Reason (Cognitive/Skill-Building)
* **Strategy:** Teach **specific replacement behaviours** to meet the functional need.
* **Action:** Explicitly teach the student to use a **"5-Step Break Card"** or the verbal phrase, "**Need a minute**," as the acceptable alternative to **{most_freq_behaviour}**.
* **Reinforcement:** Immediately and consistently reinforce the use of the replacement behaviour, even when successful compliance is only partial.

---

## 4. Chronological Incident Context (Last Detailed Log)

### Incident Date: {latest_plan_incident['date'] if latest_plan_incident else 'N/A'}
### Final Summary:
{latest_plan_incident['context'] if latest_plan_incident else 'N/A'}


*This FBA Plan is a dynamic document and must be reviewed after any further critical incident or after 30 calendar days.*
'''
    return content


def get_download_link(file_content, filename):
    """Generates a downloadable file link for Streamlit."""
    b64 = base64.b64encode(file_content.encode()).decode()
    # Create the download link in Markdown
    return f'<a href="data:file/txt;base64,{b64}" download="{filename}">â¬‡ Download Full FBA Plan (.txt)</a>'


# --- Plotly Graph Enhancement (MODIFIED for Visual Appeal) ---

def render_data_analysis(student, df):
    """
    Renders the comprehensive data analysis and clinical summary section with enhanced Plotly charts.
    """
    
    st.subheader(f"ðŸ“Š Comprehensive Data Analysis for: **{student['name']}**")
    
    # --- Data Preprocessing for Analysis ---
    df['time_obj'] = pd.to_datetime(df['time'], format='%H:%M').dt.time
    df['hour'] = pd.to_datetime(df['time'], format='%H:%M').dt.hour
    day_order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    df['day'] = pd.Categorical(df['day'], categories=day_order, ordered=True)
    
    # --- METRICS AND OVERVIEW ---
    total_incidents = len(df)
    critical_incidents = df['is_abch_completed'].sum()
    
    col_t1, col_t2, col_t3 = st.columns(3)
    col_t1.metric("Total Incidents Logged", total_incidents)
    col_t2.metric("Critical Incidents (ABCH)", critical_incidents)
    col_t3.metric("Criticality Rate", f"{critical_incidents / total_incidents * 100:.1f}%" if total_incidents > 0 else "0.0%")
    
    st.markdown("---")
    
    # --- VISUALIZATIONS ---
    
    st.markdown("#### Key Incident Tracking Visualizations (Enhanced)")
    
    col_graph1, col_graph2 = st.columns(2)
    
    # 1. INCIDENTS BY HOUR (Time Tracking)
    with col_graph1:
        st.markdown("##### ðŸ•’ Incident Frequency by Time of Day")
        hourly_counts = df.groupby('hour')['id'].count().reset_index(name='Count')
        fig_time = px.bar(
            hourly_counts, 
            x='hour', 
            y='Count', 
            title='Incidents by Hour (8:00 to 15:00)',
            template=PLOTLY_THEME,
            labels={'hour': 'Time (Hour of Day)', 'Count': 'Incident Count'},
            color_discrete_sequence=['#4CAF50'] # Green
        )
        fig_time.update_xaxes(tick0=8, dtick=1)
        fig_time.update_traces(marker_line_width=1, marker_line_color='gray')
        st.plotly_chart(fig_time, use_container_width=True)
    
    # 2. SEVERITY & CRITICALITY
    with col_graph2:
        st.markdown("##### â­ Severity and Critical Incident Breakdown")
        
        risk_critical_counts = df.groupby(['risk_level', 'is_abch_completed'])['id'].count().reset_index(name='Count')
        risk_critical_counts['is_abch_completed'] = risk_critical_counts['is_abch_completed'].replace({True: 'Critical Incident (ABCH)', False: 'Basic Log'})
        
        fig_severity = px.bar(
            risk_critical_counts,
            x='risk_level',
            y='Count',
            color='is_abch_completed',
            title='Incidents by Risk Level and Criticality',
            template=PLOTLY_THEME,
            labels={'risk_level': 'Risk Level (1=Low, 5=Extreme)', 'Count': 'Incident Count', 'is_abch_completed': 'Log Type'},
            category_orders={"risk_level": sorted(df['risk_level'].unique())},
            color_discrete_map={'Critical Incident (ABCH)': '#FF5733', 'Basic Log': '#5B5E63'} # Orange/Red for Critical
        )
        fig_severity.update_xaxes(dtick=1)
        fig_severity.update_traces(marker_line_width=1, marker_line_color='gray')
        st.plotly_chart(fig_severity, use_container_width=True)

    
    # 3. DAY OF WEEK & SUPPORT TYPE
    col_graph3, col_graph4 = st.columns(2)
    
    with col_graph3:
        st.markdown("##### ðŸ“… Incidents by Day of the Week")
        day_counts = df.groupby('day')['id'].count().reset_index(name='Count')
        fig_day = px.bar(
            day_counts,
            x='day',
            y='Count',
            title='Incident Frequency by Day',
            template=PLOTLY_THEME,
            labels={'day': 'Day of Week', 'Count': 'Incident Count'},
            color_discrete_sequence=['#3498DB'] # Blue
        )
        fig_day.update_traces(marker_line_width=1, marker_line_color='gray')
        st.plotly_chart(fig_day, use_container_width=True)

    with col_graph4:
        st.markdown("##### ðŸ¤ Incidents by Type of Support")
        support_counts = df['support_type'].value_counts().reset_index(name='Count')
        support_counts.columns = ['Support Type', 'Count']
        fig_support = px.pie(
            support_counts,
            names='Support Type',
            values='Count',
            title='Incidents Grouped by Support Type',
            template=PLOTLY_THEME,
            color_discrete_sequence=px.colors.sequential.Tealgrn # Better sequence for pie chart
        )
        fig_support.update_traces(textposition='inside', textinfo='percent+label')
        st.plotly_chart(fig_support, use_container_width=True)
    
    
    # 4. BEHAVIOUR vs. OUTCOME (SEND HOME) CORRELATION
    st.markdown("---")
    st.markdown("#### ðŸš¨ Behaviour Escalation vs. Key Outcomes")
    
    df_outcomes = df[df['is_abch_completed'] == True].copy()
    
    if not df_outcomes.empty:
        df_outcomes['Sent_Home_Flag'] = df_outcomes['outcome_send_home'].apply(lambda x: 'Sent Home (High Impact)' if x else 'Stayed at School (Managed)')
        
        # Plot: Behaviour vs. Sent Home
        outcome_by_behaviour = df_outcomes.groupby(['behaviour', 'Sent_Home_Flag'])['id'].count().reset_index(name='Count')
        
        fig_outcome = px.bar(
            outcome_by_behaviour,
            x='behaviour',
            y='Count',
            color='Sent_Home_Flag',
            title='Specific Behaviour Leading to "Sent Home" Outcome (Critical Logs)',
            template=PLOTLY_THEME,
            labels={'behaviour': 'Observed Behaviour', 'Count': 'Incident Count', 'Sent_Home_Flag': 'Final Outcome'},
            barmode='stack',
            color_discrete_map={'Sent Home (High Impact)': '#C2185B', 'Stayed at School (Managed)': '#7B1FA2'}
        )
        fig_outcome.update_traces(marker_line_width=1, marker_line_color='gray')
        fig_outcome.update_layout(xaxis={'categoryorder':'total descending'})
        st.plotly_chart(fig_outcome, use_container_width=True)

        # Additional Outcome: Assaults by Behaviour Type
        assault_by_behaviour = df_outcomes[df_outcomes['outcome_assault'] == True].groupby('behaviour')['id'].count().reset_index(name='Assault Count')
        if not assault_by_behaviour.empty:
            st.markdown("##### ðŸš© Behaviours that Escalated to Documented Assault (ABCH Logs Only)")
            fig_assault = px.bar(
                assault_by_behaviour,
                x='behaviour',
                y='Assault Count',
                title='Assault Outcomes by Behaviour Type',
                template=PLOTLY_THEME,
                labels={'behaviour': 'Observed Behaviour', 'Assault Count': 'Count of Assault Outcomes'},
                color_discrete_sequence=['#F39C12']
            )
            fig_assault.update_traces(marker_line_width=1, marker_line_color='gray')
            st.plotly_chart(fig_assault, use_container_width=True)
        else:
            st.info("No recorded assaults found in critical incident logs for this student.")

    else:
        st.info("No Critical Incidents logged yet to analyze specific outcomes.")

    
    # --- CLINICAL ANALYSIS AND RECOMMENDATIONS ---
    st.markdown("---")
    st.markdown("## ðŸ§  Clinical Analysis and Educational Recommendations")
    
    most_freq_behaviour = df['behaviour'].mode().iloc[0] if not df.empty else 'N/A'
    peak_risk = df['risk_level'].max() if not df.empty else 'N/A'
    peak_time_hour = df['hour'].mode().iloc[0] if not df.empty else 'N/A'
    peak_time = f"{peak_time_hour:02d}:00 - {peak_time_hour+1:02d}:00" if peak_time_hour != 'N/A' else 'N/A'
    
    latest_plan_incident = next(
        (i for i in reversed(st.session_state.incidents) if i['student_id'] == student['id'] and i['is_abch_completed'] == True),
        None
    )
    
    # --- 1. Key Patterns and Findings ---
    st.markdown("### 1. Key Patterns and Data Findings")
    st.markdown(f"""
    Based on the analysis of **{total_incidents}** incidents:
    * **Core Behaviour:** The most frequent behaviour is **{most_freq_behaviour}**.
    * **Time-based Risk:** The highest concentration of incidents occurs between **{peak_time}** (corresponding to {get_session_from_time(time(peak_time_hour, 0))}).
    * **Escalation Threshold:** **{critical_incidents}** incidents escalated to a Critical Incident (ABCH) level, indicating a sustained pattern of high-intensity risk (up to Risk Level **{peak_risk}**).
    * **Functional Hypothesis:** The core function often points to either **{latest_plan_incident['func_hypothesis'] if latest_plan_incident else 'Seek/Avoid Something'}**.
    """)
    
    # --- 2. Trauma-Informed and Neuro-Sequential Practice ---
    st.markdown("### 2. Neuro-Sequential & Trauma-Informed Practice")
    st.markdown("""
    To support the student's **self-regulation** and address the root causes:
    
    1.  **Regulate (Body/Physiological):** Implement a non-verbal, movement-based **Brain Break** 5 minutes prior to the identified peak time.
    2.  **Relate (Relational/Connective):** Ensure a designated 'Safe Adult' provides **predictable 1:1 check-ins** at transitions.
    3.  **Reason (Cognitive/Executive Function):** Use visual schedules and **pre-correction** scripts to clearly outline expectations and offer two acceptable choices.
    """)
    
    # --- 3. CPI Verbal Escalation Continuum ---
    st.markdown("### 3. Crisis Prevention Institute (CPI) Model: De-escalation Plan")
    
    if most_freq_behaviour in ['Physical Aggression (Staff)', 'Self-Injurious Behaviour', 'Property Destruction'] or peak_risk >= 4:
        cpi_stage = "High-Risk: Acting Out (Danger)"
        cpi_response = "Nonviolent Physical Crisis Intervention (where appropriate) followed by Therapeutic Rapport to restore the relationship and process the event."
        cpi_description = "The student has lost control and may be a danger to self or others. Intervention must focus on safety and de-escalation of the physical crisis."
    elif most_freq_behaviour in ['Aggression (Peer)', 'Elopement', 'Verbal Refusal'] or peak_risk == 3:
        cpi_stage = "Peak Risk: Defensive"
        cpi_response = "Use the **Paraverbal Communication** strategy (tone, volume, cadence) to reduce tension. Offer choices and time to decide, avoiding power struggles."
        cpi_description = "The student is losing rationality and actively resisting."
    else:
        cpi_stage = "Low-Risk: Questioning / Refusal"
        cpi_response = "Use **Supportive** language and provide a clear, concise direction."
        cpi_description = "The student is testing limits or is stressed but is still rational."
        
    
    st.markdown(f"""
    The student's frequent behaviour of **{most_freq_behaviour}** primarily indicates they are operating in the **{cpi_stage}** stage of the continuum.
    
    * **Description:** {cpi_description}
    * **Key Educational Response:** **{cpi_response}**
    """)
    
    # Show how to respond from the last detailed plan
    st.markdown("---")
    st.markdown("### ðŸ“„ Current FBA Action Plan (How to Respond)")
    
    if latest_plan_incident:
        st.success(f"Plan Last Updated: {latest_plan_incident['date']}")
        st.code(latest_plan_incident['how_to_respond'])
    else:
        st.warning("No detailed FBA Action Plan found for this student. Please complete an ABCH follow-up log to generate a plan.")


# --- Page Layout Components ---

def staff_header(role):
    """Renders the common header for JP, PY, SY pages."""
    
    nav_options = {
        'ADM': {'Home': 'home', 'Staff Management': 'staff_management', 'All Incidents': 'all_incidents'},
        'JP': {'Home': 'home'},
        'PY': {'Home': 'home'},
        'SY': {'Home': 'home'}
    }
    
    col_title, col_nav, col_back = st.columns([3, 5, 1])
    
    role_map = {'JP': 'Junior Primary (JP)', 'PY': 'Primary Years (PY)', 'SY': 'Senior Years (SY)', 'ADM': 'Admin Portal'}
    
    with col_title:
        st.markdown(f"## {role_map.get(role, 'Support Area')} Interface")

    with col_nav:
        cols = st.columns(len(nav_options.get(role, {})))
        for idx, (label, mode_name) in enumerate(nav_options.get(role, {}).items()):
            if cols[idx].button(label, key=f"nav_{mode_name}_{role}"): 
                navigate_to('staff_area', role=role, mode=mode_name)

    with col_back:
        if st.button("â¬… Home", key="back_to_landing_from_staff"):
            st.session_state.temp_incident_data = None
            st.session_state.abch_chronology = []
            navigate_to('landing')
            
    st.markdown("---")


def render_incident_log_form(student):
    """STEP 1: Logs a basic incident."""
    
    st.subheader(f"Quick Log Incident for: {student['name']}")
    st.write(f"**EDID:** {student.get('edid', 'N/A')} | **DOB:** {student.get('dob', 'N/A')}")
    st.markdown("---")

    with st.form("incident_log_form", clear_on_submit=False):
        
        st.markdown("#### Time, Setting, & Staff")
        col1, col2, col3 = st.columns(3) 
        
        current_date = datetime.now().date()
        current_time = datetime.now().time()

        with col1:
            date = st.date_input("Date of Incident", key="inc_date", value=current_date, format="DD/MM/YYYY")
        with col2:
            time_val = st.time_input("Time of Incident", key="inc_time", value=current_time, step=timedelta(minutes=1))
        
        auto_session = get_session_from_time(time_val)
        session_options = ['Morning (8:30-11:00)', 'Middle (11:01-1:00)', 'Afternoon (1:01-3:00)', 'Outside Hours']
        if auto_session not in session_options: session_options.append(auto_session)
        with col3:
            session = st.selectbox("Session", options=session_options, index=session_options.index(auto_session), key="inc_session")
        
        
        col4, col5 = st.columns(2)
        with col4:
            setting = st.selectbox("Setting (Location)", options=SETTINGS, key="inc_setting")
        with col5:
            support_type = st.selectbox("Type of Support", options=SUPPORT_TYPES, key="inc_support_type")
        
        
        staff_options_active = {s['id']: s['name'] for s in get_active_staff()}
        staff_list_names = list(staff_options_active.values())
        
        col6, col7 = st.columns(2)
        
        # Logged By (Standard/Special Staff Selection)
        final_logged_by_id = None
        logged_by_name_override = None

        with col6:
            logged_by_name = st.selectbox("Logged By (Staff)", options=staff_list_names, key="inc_logged_by_name")
            logged_by_id = [k for k, v in staff_options_active.items() if v == logged_by_name][0]
            
            is_special_logged = any(s['id'] == logged_by_id and s.get('special') for s in st.session_state.staff)
            
            if is_special_logged:
                special_role = logged_by_name
                logged_by_name_override = st.text_input(
                    f"Please enter the name of the **{special_role}** staff member", 
                    key="logged_by_special_name_input",
                    placeholder=f"E.g., John Smith (Logged as '{special_role}: John Smith')"
                )
        
        # Other Staff Involved
        other_staff_ids = []
        with col7:
            other_staff_names = st.multiselect(
                "Other Staff Involved (Select all that apply)", 
                options=[name for name in staff_list_names if name != logged_by_name],
                key="inc_other_staff"
            )
            
            for name in other_staff_names:
                staff_id = [k for k, v in staff_options_active.items() if v == name][0]
                staff_details = next(s for s in st.session_state.staff if s['id'] == staff_id)
                
                if staff_details.get('special'):
                    special_name_input = st.text_input(
                        f"Enter name for **{name}**", 
                        key=f"other_staff_special_name_input_{staff_id}",
                        placeholder=f"E.g., Jane Doe (Logged as '{name}: Jane Doe')"
                    )
                    if special_name_input:
                        other_staff_ids.append(f"{staff_id}:{special_name_input}")
                else:
                    other_staff_ids.append(staff_id)
        
        # --- Final logged_by ID construction ---
        final_logged_by_id = logged_by_id
        if is_special_logged and logged_by_name_override:
            final_logged_by_id = f"{logged_by_id}:{logged_by_name_override}"
        elif is_special_logged and not logged_by_name_override:
            # If a special role is selected but no name is entered, prevent submission
            st.error("Please enter the name for the selected special staff member.")
            submitted = False # This must be inside the form block if we want to manipulate it, but we can check it on submit


        # 3. ABC / FBA Core Data
        st.markdown("---")
        st.markdown("#### Core FBA Data (Antecedent, Behaviour, Consequence, Function)")
        
        col_a, col_b, col_c = st.columns(3)
        with col_a:
            antecedent = st.selectbox("Antecedent (Trigger)", options=ANTECEDENTS_NEW, key="inc_antecedent")
        with col_b:
            behaviour = st.selectbox("Behaviour (Action)", options=BEHAVIORS_FBA, key="inc_behaviour")
        with col_c:
            consequence = st.selectbox("Consequence/Intervention Applied", options=CONSEQUENCES, key="inc_consequence")

        st.markdown("##### Initial Functional Hypothesis")
        col_fh, col_fp, col_fs = st.columns(3)
        with col_fh:
            func_hypothesis = st.selectbox("Functional Hypothesis (Goal)", options=FUNCTIONAL_HYPOTHESIS, key="inc_func_hypothesis_quick")
        with col_fp:
            func_primary = st.selectbox("Primary Function (Mechanism)", options=FUNCTION_PRIMARY, key="inc_func_primary_quick")
        with col_fs:
            func_secondary = st.selectbox("Social Function (To whom?)", options=FUNCTION_SECONDARY, key="inc_func_secondary_quick")


        # 4. Risk and Follow-up Triggers
        st.markdown("---")
        st.markdown("#### Risk & Follow-up")
        
        col_r, col_e = st.columns(2)
        with col_r:
            risk_level = st.select_slider("Level of Risk (1=Low, 5=Extreme)", options=RISK_LEVELS, value=3, key="inc_risk_level")
        with col_e:
            effectiveness = st.selectbox("Intervention Effectiveness", options=INTERVENTION_EFFECTIVENESS, key="inc_effectiveness")
        
        requires_fba_follow_up = st.checkbox(
            "Requires Detailed ABCH Follow-up?", 
            key="inc_fba_check", 
            value=(risk_level >= 3),
            help="Check this if the incident warrants a detailed chronological narrative (ABCH)."
        )

        notes = st.text_area(
            "General Notes (Optional)", 
            max_chars=500, 
            key="inc_notes",
        )

        submitted = st.form_submit_button("Submit Incident Log", type="primary")

        if submitted:
            # Re-check the special staff name requirement on submit
            if is_special_logged and not logged_by_name_override:
                st.error("Submission blocked: Please enter the name for the selected special staff member in the 'Logged By' section.")
                return

            preliminary_incident_data = {
                'id': str(uuid.uuid4()),
                'student_id': student['id'],
                'date': date.strftime('%Y-%m-%d'),
                'time': time_val.strftime('%H:%M'),
                'day': date.strftime('%A'),
                'session': session,
                'behaviour': behaviour,
                'window_of_tolerance': None, 
                'setting': setting,
                'support_type': support_type,
                'antecedent': antecedent,
                'func_hypothesis': func_hypothesis, 
                'func_primary': func_primary,
                'func_secondary': func_secondary,
                'risk_level': risk_level,
                'consequence': consequence,
                'effectiveness': effectiveness,
                'logged_by': final_logged_by_id,
                'other_staff': other_staff_ids,
                'is_abch_completed': False, 
                'context': "Basic Log: Detailed context required on ABCH Follow-up screen." if (risk_level >= 3 or requires_fba_follow_up) else "Basic Log: No detailed context required.",
                'notes': notes,
                'how_to_respond': HOW_TO_RESPOND_DEFAULT,
                'outcome_send_home': False, 
                'outcome_leave_area': False, 
                'outcome_assault': False, 
                'outcome_property_damage': False, 
                'outcome_staff_injury': False, 
                'outcome_sapol_callout': False, 
                'outcome_ambulance': False,
            }
            
            if risk_level >= 3 or requires_fba_follow_up:
                st.session_state.temp_incident_data = preliminary_incident_data
                st.session_state.abch_chronology = []
                st.success("Log saved. Proceeding to **ABCH Follow-up** for detailed context entry.")
                navigate_to('staff_area', role=st.session_state.current_role, mode='abch_follow_up', student_id=student['id'])
            
            else:
                st.session_state.incidents.append(preliminary_incident_data)
                st.success(f"Incident for **{student['name']}** successfully logged (Basic Detail).")
                if st.session_state.current_page == 'direct_log_form':
                    navigate_to('landing')
                else:
                    navigate_to('staff_area', role=st.session_state.current_role, mode='analysis', student_id=student['id'])


def render_abch_follow_up_form(student):
    """STEP 2: Detailed ABCH follow-up screen."""
    
    prelim_data = st.session_state.temp_incident_data
    if not prelim_data:
        st.error("Error: No preliminary incident data found. Please restart the log process.")
        navigate_to('staff_area', role=st.session_state.current_role, mode='home', student_id=student['id'])
        return
        
    if not st.session_state.abch_chronology:
        add_abch_entry()

    st.subheader(f"Detailed Critical Incident Form for: {student['name']}")
    st.write(f"**EDID:** {student.get('edid', 'N/A')} | **DOB:** {student.get('dob', 'N/A')}")
    st.info("The basic log is captured. Now detail the chronological narrative (ABCH) and provide a final summary.")
    st.markdown("---")

    # --- ABCH Chronological Log (Dynamic Table) ---
    st.markdown("#### ABCH Chronological Narrative Log (Multi-Layered Incident)")

    cols_header = st.columns([1.5, 2, 0.7, 2, 2, 2.5])
    cols_header[0].markdown("**Location**") 
    cols_header[1].markdown("**Context (A)**") 
    cols_header[2].markdown("**Time**")       
    cols_header[3].markdown("**Behaviour (B)**")
    cols_header[4].markdown("**Consequences (C)**")
    cols_header[5].markdown("**Function (Auto-Hypothesis)**")

    new_chronology = []
    for i, entry in enumerate(st.session_state.abch_chronology):
        with st.container(border=True):
            entry_key = f"abch_entry_{entry['id']}_{i}" 
            cols = st.columns([1.5, 2, 0.7, 2, 2, 2.5])

            entry['location'] = cols[0].text_area(
                f"Location {i+1}", 
                value=entry.get('location', ''),
                key=f"location_{entry_key}", 
                height=90, 
                label_visibility="collapsed", 
            )
            
            entry['context'] = cols[1].text_area(
                f"Context {i+1}", 
                value=entry.get('context', ''),
                key=f"context_{entry_key}", 
                height=90, 
                label_visibility="collapsed", 
            )
            
            entry['time'] = cols[2].text_input(
                f"Time {i+1}", 
                value=entry['time'], 
                key=f"time_{entry_key}", 
                label_visibility="collapsed", 
            )

            entry['behaviour'] = cols[3].text_area(
                f"Behaviour {i+1}", 
                value=entry['behaviour'], 
                key=f"behaviour_{entry_key}", 
                height=90, 
                label_visibility="collapsed", 
            )

            consequence_input = cols[4].text_area(
                f"Consequence {i+1}", 
                value=entry['consequence'], 
                key=f"consequence_{entry_key}", 
                height=90, 
                label_visibility="collapsed", 
            )
            entry['consequence'] = consequence_input

            entry['function_auto'] = guess_function(entry['consequence'])
            
            cols[5].markdown(f"**Layer {i+1} Function:** \n\n**{entry['function_auto']}**") 
            
            new_chronology.append(entry)

    st.session_state.abch_chronology = new_chronology

    if st.button("âž• Add Incident Layer (Multi-Layered Incident)", key="add_abch_layer_btn", type="secondary"):
        add_abch_entry()

    # --- Final Summary and Save ---
    st.markdown("---")
    
    with st.form("abch_final_form", clear_on_submit=True):

        # 1. Final FBA Refinement (H - How to Respond / Final WOT)
        st.markdown("#### Final FBA Refinement and Action Plan (H)")
        
        refined_wot = st.selectbox(
            "Window of Tolerance State (Student state during escalation)", 
            options=WINDOW_OF_TOLERANCE, 
            key="abch_wot"
        )
        
        final_summary = st.text_area(
            "Final Clinical Summary / Root Cause Analysis (Mandatory)", 
            key="abch_final_notes",
            height=150
        )
        
        # --- INTENDED OUTCOMES (REPLICATING THE SCREENSHOT TABLE) ---
        st.markdown("---")
        st.markdown("#### ðŸ“ INTENDED OUTCOMES")

        col_left_table, col_right_table = st.columns([5, 5]) 

        with col_left_table:
            st.markdown("##### Incident Details & Outcomes Checklist")
            
            col_t_h, col_o_h, col_l_h = st.columns([1, 4, 0.5])
            col_t_h.markdown("**TIME**")
            col_o_h.markdown("**OUTCOMES**")
            col_l_h.markdown("**ID**") 
            
            col_t_a, col_o_a, col_l_a = st.columns([1, 4, 0.5])
            col_t_a.text_input("Time a", value="11:30", disabled=False, label_visibility="collapsed", key="t_a")
            send_home_checked = col_o_a.checkbox("Send Home. Parent/Caregiver notified via phone call.", key="o_a_send_home")
            col_l_a.markdown("**:blue[a]**")
            
            st.markdown("---")
            st.markdown("##### Incident Type Checkboxes (b-j)")
            
            leave_area_checked = st.checkbox("b. Student leaving supervised areas/leaving school grounds", key="o_b_leave_area")
            st.checkbox("c. Sexualised behaviour", key="o_c_sexualised")
            st.checkbox("d. Incident - student to student", key="o_d_stu_stu")
            st.checkbox("e. Complaint by co-located school / member of public", key="o_e_complaint")
            damage_checked = st.checkbox("f. Property damage", key="o_f_damage")
            st.checkbox("g. Stealing", key="o_g_stealing_left")
            st.checkbox("h. Toileting issue", key="o_h_toileting")
            staff_injury_checked = st.checkbox("i. ED155: Staff Injury (submit with report)", key="o_i_staff_injury")
            st.checkbox("j. ED155: Student injury (submit with report)", key="o_j_student_injury")

            st.markdown("---")
            st.markdown("##### Notification Checklist")
            st.checkbox("Notified Line Manager of Critical Incident **YES**", key="notif_line_manager")
            st.checkbox("Notified Parent / Caregiver of Critical Incident **YES**", key="notif_parent")
            st.checkbox("Copy of Critical Incident in student file **YES**", key="copy_to_file")


        with col_right_table:
            st.markdown("##### Emergency Services Outcomes")
            col_title_sapol, col_report_num = st.columns([3, 2])
            col_title_sapol.markdown("###### **SAPOL**")
            report_num = col_report_num.text_input("Report Number", key="report_number", placeholder="Enter Report Number")
            st.markdown("---")
            
            st.markdown("###### SAPOL Incident Types (k-q):")
            col_k_m, col_n_q = st.columns(2)
            with col_k_m:
                st.checkbox("k. Drug possession", key="o_k_drug")
                assault_checked = st.checkbox("l. Assault", key="o_l_assault")
                st.checkbox("m. Absconding", key="o_m_absconding")
            with col_n_q:
                st.checkbox("n. Removal", key="o_n_removal")
                sapol_callout_checked = st.checkbox("o. Call Out", key="o_o_call_out")
                st.checkbox("p. Stealing", key="o_p_stealing_sapol")
                st.checkbox("q. Vandalism", key="o_q_vandalism")
                
            st.markdown("---")
            st.markdown("###### **SA Ambulance Services** (r-s):")
            amb_call_checked = st.checkbox("r. Call out", key="o_r_call_out_amb")
            st.checkbox("s. Taken to Hospital", key="o_s_hospital")
            st.text_input("Time of action 'r' or 's'", value="11:10", disabled=False, label_visibility="visible", key="t_rs")

            st.markdown("---")
            st.markdown("##### Incident Internally Managed")
            st.checkbox("Restorative Session", key="i_restorative")
            st.checkbox("Community Service", key="i_community")
            st.checkbox("Re-Entry", key="i_re_entry")
            st.checkbox("Case Review", key="i_case_review")
            st.checkbox("Make-up Time", key="i_make_up_time")
            st.text_area("Other (Specify)", key="i_other_managed", height=50, placeholder="Other internal action...")

            st.markdown("---")
            st.markdown("A **TAC meeting** will be held to discuss solutions to support [Insert Student Name].", unsafe_allow_html=True) 

        # --- ADMINISTRATION ONLY (Signatures and Review) ---
        st.markdown("---")
        st.markdown("#### ADMINISTRATION ONLY")
        
        col_sig1, col_sig2 = st.columns(2)
        with col_sig1:
            st.text_input("Line Manager Signature (Typed Name)", key="sig_line_manager")
        with col_sig2:
            st.text_input("Manager Signature (Typed Name)", key="sig_manager")
        
        st.text_area("Safety and Risk Plan: To be developed / reviewed:", 
                     key="safety_risk_plan", height=80, 
                     placeholder="Specify the next steps for RMP update.")
        
        st.text_area("Other outcomes to be pursued by Cowandilla Learning Centre Management:", 
                     key="cowandilla_management_outcomes", height=80)

        final_submitted = st.form_submit_button("Finalize and Save ABCH Follow-up Log", type="primary")

        if final_submitted:
            
            # 1. Compile chronological and clinical summary into final context
            final_context = "Chronological Log:\n"
            for i, entry in enumerate(st.session_state.abch_chronology):
                if entry['location'] or entry['context'] or entry['behaviour'] or entry['consequence']:
                    final_context += f"Layer {i+1} ({entry['time']}): L: {entry['location'] or 'N/A'}; A: {entry['context'] or 'N/A'}; B: {entry['behaviour'] or 'N/A'}; C: {entry['consequence'] or 'N/A'}; F: {entry['function_auto']}\n"
            
            final_context += f"\n--- CLINICAL SUMMARY ---\n{final_summary}"
            
            outcomes_notes = "--- FOLLOW-UP OUTCOMES CHECKLIST ---\n"
            outcomes_notes += f"a. Send Home: {send_home_checked}\n"
            outcomes_notes += f"b. Leave Area: {leave_area_checked}\n"
            outcomes_notes += f"f. Property damage: {damage_checked}\n"
            outcomes_notes += f"i. ED155 Staff Injury: {staff_injury_checked}\n"
            outcomes_notes += f"l. Assault: {assault_checked}\n"
            outcomes_notes += f"o. SAPOL Call Out: {sapol_callout_checked}\n"
            outcomes_notes += f"r. Ambulance Call Out: {amb_call_checked}\n"
            outcomes_notes += f"--- ADMINISTRATION ---\n"
            outcomes_notes += f"Manager Sig: {st.session_state.sig_manager or 'N/A'}\n"
            outcomes_notes += f"Safety/Risk Plan Review: {st.session_state.safety_risk_plan or 'N/A'}\n"

            final_context += f"\n\n{outcomes_notes}"


            prelim_data['window_of_tolerance'] = refined_wot
            prelim_data['is_abch_completed'] = True
            prelim_data['context'] = final_context
            prelim_data['how_to_respond'] = final_summary
            
            # Crucially update the specific outcome fields from the form checks for later analysis
            prelim_data['outcome_send_home'] = send_home_checked
            prelim_data['outcome_leave_area'] = leave_area_checked
            prelim_data['outcome_assault'] = assault_checked
            prelim_data['outcome_property_damage'] = damage_checked
            prelim_data['outcome_staff_injury'] = staff_injury_checked
            prelim_data['outcome_sapol_callout'] = sapol_callout_checked
            prelim_data['outcome_ambulance'] = amb_call_checked


            # 2. Save the final incident and clear temp state
            st.session_state.incidents.append(prelim_data)
            st.session_state.temp_incident_data = None
            st.session_state.abch_chronology = []
            
            st.success(f"Critical Incident for **{student['name']}** successfully logged and ABCH completed!")
            navigate_to('staff_area', role=st.session_state.current_role, mode='analysis', student_id=student['id'])


def render_staff_area():
    """Renders the main staff area dashboard based on role and mode."""
    role = st.session_state.current_role
    student_id = st.session_state.selected_student_id
    mode = st.session_state.mode

    staff_header(role)
    
    if mode == 'home' and role != 'ADM':
        st.subheader(f"Students in the **{role}** Area")
        area_students = get_students_by_area(role)
        
        if not area_students:
            st.warning("No students assigned to this area.")
            return

        cols = st.columns(len(area_students))
        for idx, student in enumerate(area_students):
            student_incidents = get_incidents_by_student(student['id'])
            incident_count = len(student_incidents)
            
            with cols[idx]:
                container = st.container(border=True)
                container.markdown(f"**{student['name']}**")
                container.write(f"Grade: **{student['grade']}**")
                container.write(f"Teacher: **{student['teacher']}**")
                container.info(f"Incidents Logged: **{incident_count}**")
                
                if container.button("View Details / Log Incident", key=f"select_stu_{student['id']}", use_container_width=True):
                    navigate_to('staff_area', role=role, mode='analysis', student_id=student['id'])
    
    elif mode == 'analysis' and student_id:
        student = get_student_by_id(student_id)
        if not student:
            st.error("Student not found.")
            navigate_to('staff_area', role=role, mode='home')
            return

        st.title(f"Student Profile: {student['name']}")
        
        tab1, tab2, tab3 = st.tabs(["ðŸ“Š Data Analysis & Clinical Summary", "ðŸ“ New Incident Log", "ðŸ“„ Full FBA Plan"])

        with tab2:
            render_incident_log_form(student)

        with tab1:
            incidents = get_incidents_by_student(student_id)
            if incidents:
                df = pd.DataFrame(incidents)
                render_data_analysis(student, df)
            else:
                st.info("No incident data logged for this student yet. Start with the 'New Incident Log' tab.")

        with tab3:
            st.markdown("### Functional Behavioural Assessment (FBA) Plan")
            
            incidents = get_incidents_by_student(student_id)
            df = pd.DataFrame(incidents)
            
            latest_plan_incident = next(
                (i for i in reversed(incidents) if i['is_abch_completed'] == True),
                None
            )
            
            if latest_plan_incident and not df.empty:
                fba_content = generate_fba_report_content(student, latest_plan_incident, df)
                
                # Display the content
                st.markdown(fba_content, unsafe_allow_html=True)
                
                st.markdown("---")
                # Provide the download link
                filename = f"FBA_Plan_{student['name'].replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.txt"
                st.markdown(get_download_link(fba_content, filename), unsafe_allow_html=True)
                st.info("The **.txt** file contains the full formatted report in Markdown. You can easily copy the content or use your browser's Print function (Ctrl+P or Cmd+P) and choose 'Save as PDF' for a formatted download.")
                
            else:
                st.warning("A full FBA Plan requires a minimum of **one completed Critical Incident Log (ABCH Follow-up)** to generate the detailed context, hypothesis, and action plan.")
                st.markdown("Navigate to **ðŸ“ New Incident Log** to start the process.")


    elif mode == 'abch_follow_up' and student_id:
        student = get_student_by_id(student_id)
        if student:
            render_abch_follow_up_form(student)
        else:
            st.error("Student not found for ABCH form.")
            navigate_to('staff_area', role=st.session_state.current_role, mode='home')
            
    elif mode == 'home' and role == 'ADM':
        st.subheader("Admin Dashboard: Overview")
        st.info("Use the navigation buttons above for Staff Management and All Incidents view.")
        
        total_incidents = len(st.session_state.incidents)
        detailed_logs = len([i for i in st.session_state.incidents if i['is_abch_completed']])
        
        col_t1, col_t2 = st.columns(2)
        col_t1.metric("Total Incidents Logged", total_incidents)
        col_t2.metric("Detailed ABCH Logs", detailed_logs)
        
    elif mode == 'staff_management' and role == 'ADM':
        st.subheader("Staff Account Management")
        st.write("Manage active staff members and their roles.")
        st.dataframe(pd.DataFrame(st.session_state.staff), use_container_width=True)

    elif mode == 'all_incidents' and role == 'ADM':
        st.subheader("All Incidents Logged (Admin View)")
        
        df_all = pd.DataFrame(st.session_state.incidents)
        student_id_to_name = {s['id']: s['name'] for s in st.session_state.students}
        df_all['student_name'] = df_all['student_id'].map(student_id_to_name)
        
        if not df_all.empty:
            st.dataframe(df_all[['date', 'student_name', 'behaviour', 'risk_level', 'is_abch_completed', 'logged_by']], use_container_width=True)
        else:
            st.info("No incidents logged in the system.")


def render_landing_page():
    """Renders the initial screen for role selection."""
    st.title("ðŸ“š Behaviour Support & Data Analysis Tool")
    st.markdown("---")
    st.subheader("Please Select Your Role/Area to Continue:")
    
    col_jp, col_py, col_sy, col_adm, col_log = st.columns(5)
    
    with col_jp:
        if st.button("Junior Primary (JP)", use_container_width=True, type="primary"):
            navigate_to('staff_area', role='JP')
    with col_py:
        if st.button("Primary Years (PY)", use_container_width=True, type="primary"):
            navigate_to('staff_area', role='PY')
    with col_sy:
        if st.button("Senior Years (SY)", use_container_width=True, type="primary"):
            navigate_to('staff_area', role='SY')
    with col_adm:
        if st.button("Admin Portal (ADM)", use_container_width=True, type="secondary"):
            navigate_to('staff_area', role='ADM')
    
    st.markdown("---")
    st.subheader("Quick Log Incident (No Area Selection)")
    
    student_names = [s['name'] for s in st.session_state.students]
    student_id_map = {s['name']: s['id'] for s in st.session_state.students}
    
    selected_student_name = st.selectbox("Select Student to Log Incident Directly:", options=[''] + student_names, index=0)
    
    if selected_student_name:
        selected_student_id = student_id_map[selected_student_name]
        if st.button(f"Start Quick Log for {selected_student_name}"):
            st.session_state.temp_log_area = 'direct' 
            navigate_to('direct_log_form', student_id=selected_student_id)

def render_direct_log_form():
    """Renders the incident log form directly after selection from the landing page."""
    student = get_student_by_id(st.session_state.selected_student_id)
    if student:
        col_title, col_back = st.columns([4, 1])
        with col_title:
            st.markdown(f"## Quick Incident Log (Step 1)")
        with col_back:
            if st.button("â¬… Change Student", key="back_to_direct_select_form"):
                navigate_to('landing')
        st.markdown("---")
        
        render_incident_log_form(student)
    else:
        st.error("No student selected.")
        navigate_to('landing')

# --- Main App Execution ---

def main():
    """The main function to drive the Streamlit application logic."""
    
    if st.session_state.current_page == 'landing':
        render_landing_page()
    elif st.session_state.current_page == 'staff_area':
        render_staff_area()
    elif st.session_state.current_page == 'direct_log_form':
        render_direct_log_form()

if __name__ == "__main__":
    main()